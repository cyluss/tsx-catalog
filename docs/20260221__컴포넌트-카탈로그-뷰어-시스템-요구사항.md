# 컴포넌트 카탈로그 뷰어 시스템 요구사항

## 배경과 목적

스토리북(Storybook)은 컴포넌트를 격리해서 시각적으로 확인하는 문제를 해결했다. 그런데 그 과정에서 독립적인 빌드 시스템, 별도의 스토리 파일, 복잡한 설정을 요구하는 무거운 플랫폼이 됐다. 에이전트가 읽는 문서와 사람이 보는 문서가 분리되어 있어서 두 파일이 동기화되지 않는 문제도 생겼다.

이 시스템은 다른 전제에서 출발한다. 컴포넌트 카탈로그는 마크다운 파일 하나다. 에이전트는 그 마크다운을 읽고 판단 규칙을 얻는다. 사람은 같은 파일을 브라우저에서 열어서 실제로 렌더링된 컴포넌트를 확인한다. 하나의 파일이 두 독자를 동시에 만족시킨다. 스토리북이 렌더링 중심으로 설계하고 문서를 부가적으로 붙인 것과 반대 방향이다. 문서가 중심이고 렌더링이 그 위에 올라간다.

Island 아키텍처가 이것을 가능하게 한다. 마크다운 문서의 대부분은 정적 HTML로 표시하고, `jsx live` 메타데이터가 붙은 코드 블록만 React island로 격리해서 렌더링한다. 페이지 전체를 React로 만들 필요가 없다. 코드 블록이 있는 곳에만 React가 올라간다.

---

## 핵심 설계 결정

에이전트가 읽는 파일과 사람이 보는 파일이 같아야 한다. 이것이 이 시스템의 가장 중요한 설계 결정이다. 에이전트용 md 파일과 스토리북 파일이 분리되면 두 파일 중 하나가 반드시 오래된다. 컴포넌트가 변경됐을 때 스토리북 파일은 업데이트했지만 md 파일은 잊어버리는 일이 생긴다. 그 순간 에이전트가 잘못된 판단 규칙을 읽게 된다. 파일이 하나면 이 문제가 구조적으로 사라진다.

빌드 시스템을 프로젝트와 분리하지 않는다. 스토리북의 복잡도 원인 중 하나가 프로젝트와 독립적인 빌드 파이프라인을 가진다는 것이다. 이 시스템은 마크다운 파서와 Island 렌더러만 있으면 작동한다. 프로젝트의 빌드 시스템을 그대로 사용한다.

---

## 입출력 명세

입력은 마크다운 파일이다. 파일 안의 코드 블록에 `jsx live` 메타데이터가 붙어 있으면 그 블록이 React island 후보가 된다. 메타데이터가 없는 코드 블록은 일반 코드 예시로 표시된다.

```
# Button 컴포넌트

사용 시점: 사용자 액션을 트리거하는 모든 버튼에 사용한다.

```jsx live
<Button variant="primary">저장</Button>
<Button variant="danger">삭제</Button>
```

선택 규칙: 한 화면에 variant="primary"는 하나만 사용한다.
```

출력은 정적 HTML과 React island가 혼합된 페이지다. 텍스트와 판단 규칙은 정적 HTML로 표시된다. `jsx live` 블록은 실제로 렌더링된 컴포넌트로 교체된다. 각 island는 독립적으로 마운트된다. 하나의 island가 에러를 내도 다른 island와 정적 콘텐츠에 영향을 주지 않는다.

---

## 파이프라인 구조

```
component-catalog.md
        ↓
  마크다운 파서 (remark / unified)
        ↓
  AST 변환: jsx live 블록 감지
        ↓
  정적 HTML 생성 + Island 컨테이너 삽입
        ↓
  브라우저 로드
        ↓
  Island 컨테이너 감지 → ReactDOM.createRoot 마운트
        ↓
  컴포넌트 렌더링
```

파이프라인의 각 단계가 독립적으로 교체 가능해야 한다. 마크다운 파서를 바꿔도 Island 렌더러에 영향이 없고, Island 렌더러를 바꿔도 파서에 영향이 없다. 각 단계가 명확한 입출력 계약을 가진다.

---

## 기능 요구사항

### 마크다운 파싱

파서는 `jsx live` 메타데이터가 붙은 코드 블록을 감지하고 Island 컨테이너로 교체한다. 컨테이너에는 원본 JSX 코드가 data 속성으로 저장된다. 브라우저에서 이 data 속성을 읽어서 컴포넌트를 렌더링한다. `jsx live` 외의 메타데이터가 붙은 블록은 일반 코드 하이라이팅으로 처리한다.

### Island 렌더링

각 Island는 독립적인 React 루트로 마운트된다. Island 안에서 컴포넌트를 import할 때 프로젝트의 컴포넌트 경로를 그대로 사용한다. 별도의 alias 설정이 필요 없다. Island가 렌더링에 실패하면 에러 경계(Error Boundary)가 에러 메시지를 표시하고 나머지 페이지는 정상적으로 표시된다.

### 코드 블록 표시

`jsx live` 메타데이터가 없는 코드 블록은 렌더링하지 않고 코드 하이라이팅만 적용해서 표시한다. 에이전트가 읽을 때 판단 규칙의 예시 코드로 사용된다. 사람이 볼 때 복사해서 사용할 수 있는 참조 코드로 표시된다.

### 네비게이션

마크다운의 헤딩 구조를 읽어서 사이드바 네비게이션을 자동으로 생성한다. 헤딩이 변경되면 네비게이션이 자동으로 업데이트된다. 별도로 네비게이션을 관리하는 파일이 없다. 마크다운이 유일한 진실의 원천이다.

### 다크 모드

시스템 설정을 따른다. 별도의 토글 없이 운영체제의 다크 모드 설정을 자동으로 반영한다. Island로 렌더링된 컴포넌트도 같은 다크 모드 설정을 따른다.

---

## 비기능 요구사항

초기 로드 시간은 2초 이내여야 한다. Island 아키텍처가 이것을 구조적으로 보장한다. 페이지 전체를 React로 렌더링하지 않기 때문에 초기 JavaScript 번들이 작다. 각 Island의 JavaScript는 해당 컴포넌트가 뷰포트에 들어올 때 지연 로드한다.

마크다운 파일이 변경되면 브라우저가 자동으로 새로고침한다. 개발 중에 컴포넌트를 수정하고 카탈로그에서 즉시 확인할 수 있어야 한다. 스토리북의 핫 리로드와 같은 경험을 제공한다.

---

## 에이전트 사용 요구사항

에이전트가 이 시스템에서 필요한 것은 렌더링이 아니라 텍스트다. 에이전트가 카탈로그를 읽을 때 마크다운 파일을 직접 읽는다. 뷰어를 실행할 필요가 없다. 마크다운 파일 자체가 에이전트의 판단 규칙집이다. `jsx live` 블록 안의 코드는 에이전트에게 사용 예시로 읽힌다. 렌더링 결과를 볼 수 없는 에이전트에게 코드 예시가 시각적 렌더링을 대체한다.

에이전트가 새 컴포넌트를 사용할 때 따라야 할 규칙이 있다. 카탈로그에 없는 컴포넌트를 임의로 만들지 않는다. 카탈로그에 없는 컴포넌트가 필요하면 이슈를 반려하고 컴포넌트 추가 이슈를 먼저 요청한다. `jsx live` 블록의 예시 코드를 패턴으로 따라서 새 사용 코드를 작성한다.

---

## 구현 범위

이 시스템은 처음부터 만드는 것이 아니라 기존 도구를 조합하는 작업이다. 핵심 파이프라인은 remark와 unified를 사용한 마크다운 파싱, `jsx live` 블록을 Island 컨테이너로 변환하는 remark 플러그인, ReactDOM.createRoot를 사용한 Island 마운터 세 부분으로 구성된다. 이 세 부분이 핵심이고 나머지는 부가적이다.

스코프 밖의 것들이 있다. 컴포넌트 편집기, props 인터랙티브 조작, 접근성 자동 검사, 시각적 회귀 테스트가 스코프 밖이다. 스토리북이 이것들을 전부 포함하려다 복잡해졌다. 이 시스템은 "마크다운을 읽고 JSX 블록을 렌더링한다"는 핵심만 구현한다. 나머지는 필요할 때 추가한다.

---

## 성공 조건

뷰어의 성공 조건은 세 가지다. 첫 번째는 component-catalog.md 파일 하나가 에이전트와 사람 두 독자를 동시에 만족시키는 것이다. 에이전트는 마크다운을 읽고, 사람은 브라우저에서 렌더링된 컴포넌트를 확인한다. 두 번째는 `jsx live` 블록이 Island로 렌더링되고, 하나의 Island 에러가 다른 콘텐츠에 영향을 주지 않는 것이다. 세 번째는 마크다운 헤딩 구조에서 네비게이션이 자동으로 생성되어 별도의 네비게이션 파일이 필요 없는 것이다.

스토리북 대비 성공 조건이 하나 더 있다. 설정 파일 없이 마크다운 파일만으로 뷰어가 작동해야 한다. 설정이 필요한 순간 이 시스템이 스토리북과 같은 방향으로 가는 것이다.

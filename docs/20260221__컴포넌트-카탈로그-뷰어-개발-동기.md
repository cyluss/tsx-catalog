# 컴포넌트 카탈로그 뷰어: 개발 동기

## 한 줄 요약

팀장인 나의 프론트엔드 블로커를 제거하기 위한 내부 도구다.

---

## 문제 정의

### 블로커의 연쇄 구조

GitLab Dev Agent가 프론트엔드 뼈대 컴포넌트를 만들려면 컴포넌트 카탈로그가 있어야 한다. 카탈로그가 없으면 에이전트가 임의의 클래스 조합을 만들어낸다. 일관성이 없는 초벌이 나온다. 팀장이 MR에서 그것을 수정해야 한다. 수정이 블로커가 된다.

컴포넌트 카탈로그 md 파일이 이 블로커를 제거한다. 에이전트가 판단 규칙을 읽고 일관된 초벌을 만든다. 팀장이 MR에서 구조적 판단에 집중할 수 있다.

그런데 새 블로커가 생긴다. 팀장이 카탈로그에 새 컴포넌트를 추가하거나 기존 컴포넌트를 수정할 때, "이것이 실제로 어떻게 보이는가"를 확인해야 한다. 텍스트만으로는 시각적 결과를 알 수 없다. 지금은 확인하려면 스토리북을 설정하거나, 해당 컴포넌트가 있는 페이지를 직접 열어서 상태를 만들어내야 한다. disabled 상태를 보려면 폼 유효성 검사를 일부러 실패시켜야 하고, loading 상태를 보려면 API 응답을 늦춰야 한다. 이 과정이 팀장에게 또 다른 블로커가 된다.

```
카탈로그 md 없음
    ↓
에이전트가 임의 클래스 조합 → 일관성 없는 초벌
    ↓
팀장이 MR에서 수정 (블로커 1)

카탈로그 md 있음, 뷰어 없음
    ↓
에이전트가 일관된 초벌 생성 (블로커 1 해결)
    ↓
팀장이 카탈로그 업데이트 시 시각적 확인 불가
    ↓
스토리북 설정 또는 페이지 직접 열기 (블로커 2)

카탈로그 md + 뷰어
    ↓
에이전트가 일관된 초벌 생성 (블로커 1 해결)
    ↓
팀장이 md 파일 열면 렌더링된 컴포넌트 확인 (블로커 2 해결)
```

---

## 스토리북이 이 문제를 해결하지 못하는 이유

스토리북은 컴포넌트를 격리해서 시각적으로 확인하는 문제를 해결했다. 그런데 그 과정에서 독립적인 빌드 시스템, 별도의 스토리 파일, 복잡한 설정을 요구하는 무거운 플랫폼이 됐다. 팀장이 스토리북을 도입하고 유지하는 것 자체가 비용이다. 그 비용이 블로커를 제거하는 이득보다 크다.

더 근본적인 문제가 있다. 스토리북은 에이전트를 독자로 설계하지 않았다. 에이전트가 스토리북에서 필요한 것은 시각적 렌더링이 아니라 "이 컴포넌트를 어떻게 사용하는가"라는 텍스트 정보다. 렌더링 결과를 볼 수 없는 에이전트에게 스토리북의 시각적 기능은 의미가 없다. 결과적으로 에이전트용 md 파일과 스토리북 파일이 따로 존재하게 된다. 두 파일이 동기화되지 않으면 에이전트가 잘못된 판단 규칙을 읽는다.

스토리북이 마크다운을 부가적으로 붙인 것과 반대 방향이 필요하다. 마크다운이 중심이고 렌더링이 그 위에 올라가는 구조다.

---

## 핵심 설계 결정

### 하나의 파일이 두 독자를 만족시킨다

에이전트는 마크다운 텍스트에서 판단 규칙을 읽는다. 사람은 같은 파일을 브라우저에서 열어서 렌더링된 컴포넌트를 확인한다. 파일이 하나이기 때문에 동기화 문제가 구조적으로 사라진다. 컴포넌트가 변경됐을 때 스토리북 파일은 업데이트했지만 md 파일은 잊어버리는 일이 생기지 않는다.

### Island 아키텍처가 복잡도를 낮춘다

페이지 전체를 React로 렌더링하지 않는다. 마크다운 문서의 대부분은 정적 HTML로 표시하고, `jsx live` 메타데이터가 붙은 코드 블록만 React island로 격리해서 렌더링한다. 독립적인 빌드 시스템이 필요 없다. 프로젝트의 빌드 시스템을 그대로 사용한다.

### 설정 파일이 없어야 한다

설정이 필요한 순간 스토리북과 같은 방향으로 가는 것이다. 마크다운 파일만 있으면 뷰어가 작동해야 한다. 팀장이 새 컴포넌트를 카탈로그에 추가할 때 추가로 해야 할 일이 없어야 한다. md 파일을 수정하면 뷰어에 즉시 반영된다.

---

## 이 도구가 팀장 블로커를 제거하는 방식

```
팀장이 새 컴포넌트 추가 결정
    ↓
component-catalog.md에 항목 작성
    ↓
브라우저에서 md 파일 열기
    ↓
jsx live 블록이 Island로 렌더링됨
    ↓
시각적 확인 완료
    ↓
에이전트가 카탈로그를 읽고 새 컴포넌트 사용
```

팀장이 하는 것은 md 파일 수정과 브라우저 확인이다. 스토리북 설정, 스토리 파일 작성, 빌드 파이프라인 관리가 없다. 블로커가 제거된다.

---

## 오늘 논의한 전체 구조와의 연결

이 뷰어는 독립적인 도구가 아니다. GitLab Dev Agent, 컴포넌트 카탈로그, 컴포넌트 카탈로그 뷰어가 하나의 연결된 구조를 만든다.

```
컴포넌트 카탈로그 뷰어
    → 팀장이 카탈로그를 시각적으로 확인하고 업데이트한다

컴포넌트 카탈로그 md
    → 에이전트가 판단 규칙을 읽는다
    → 일관된 초벌이 나온다

GitLab Dev Agent
    → 뻔한 작업을 처리한다
    → 팀장이 판단이 필요한 작업에 집중한다
```

각 도구가 다음 도구의 블로커를 제거한다. 뷰어가 카탈로그 유지보수를 쉽게 만들고, 카탈로그가 에이전트의 초벌 품질을 높이고, 에이전트가 팀장의 코딩 병목을 제거한다.

---

## 만드는 이유가 시장이 아니라 내부 필요이다

스토리북, Vite, Astro가 존재한다. 그런데 이 조합이 오늘 논의한 요구사항을 전부 만족시키는 도구가 없다. 각자 문제의 일부만 해결한다. 그 간격을 메우는 것이 이 뷰어다.

이 도구를 시장에 팔 필요가 없다. 투자자에게 보여줄 필요가 없다. 4개월 안에 출시할 필요가 없다. 팀장인 나의 블로커를 제거하는 것이 목적의 전부다. 이 조건이 스토리북이 무거워진 이유와 정반대다. 스토리북은 모든 팀, 모든 프로젝트, 모든 컴포넌트를 만족시키려다 복잡해졌다. 이 뷰어는 나 하나의 블로커를 제거하는 것만 하면 된다. 핵심만 구현한다.

---

## 성공 조건

component-catalog.md 파일 하나가 에이전트와 팀장 두 독자를 동시에 만족시키는 것이다. 에이전트는 텍스트로 판단 규칙을 읽고, 팀장은 브라우저에서 렌더링된 컴포넌트를 확인한다. 설정 파일 없이 md 파일만으로 뷰어가 작동한다. 카탈로그를 업데이트하는 것 외에 팀장이 추가로 해야 할 일이 없다.

이것이 달성되면 프론트엔드 블로커 연쇄가 끊어진다.

# 컴포넌트 카탈로그 뷰어: 설계 결정

## 설계 결정 목록

이 문서는 뷰어를 만들면서 내린 설계 결정을 기록한다. 각 결정이 왜 그 방향으로 됐는지, 어떤 대안을 검토했는지, 어떤 트레이드오프를 감수했는지를 남긴다. 나중에 이 결정을 바꿔야 할 때 맥락을 잃지 않기 위해서다.

---

## 결정 1: 빌드 도구는 Vite를 사용한다

Vanilla JS, Next.js, Vite 세 가지를 검토했다.

Vanilla JS는 설정 파일이 없다는 원칙에 가장 잘 맞는다. HTML 파일 하나와 CDN으로 React와 `@babel/standalone`을 불러오면 된다. 그런데 컴포넌트 라이브러리가 TypeScript와 ES 모듈로 작성되어 있기 때문에 브라우저가 직접 읽을 수 없다. 컴포넌트를 UMD 번들로 별도로 빌드하는 단계가 어떤 형태로든 필요해진다. 그 빌드 단계를 추가하는 순간 Vanilla JS의 단순함이 사라진다.

Next.js는 이 뷰어가 필요로 하지 않는 것들을 가져온다. SEO가 필요 없고, 서버 사이드 렌더링이 필요 없고, API 라우트가 필요 없다. Next.js를 쓰면 `next.config.js`가 생기고, app 디렉토리 구조가 강제되고, 배포할 때 Node.js 서버가 필요하다. 필요 없는 복잡도다.

Vite가 맞는 이유는 팀 표준이기 때문이다. 새로운 도구를 배울 필요가 없고, 기존 프로젝트의 설정을 참조할 수 있고, TypeScript와 모듈 시스템이 이미 작동하는 환경이다. `vite.config.js` 몇 줄로 시작하고, 빌드 결과물이 정적 파일이라 어디서든 호스팅할 수 있다. 핫 리로드도 공짜로 따라온다.

---

## 결정 2: JSX 문자열 렌더링은 react-live를 사용한다

마크다운 파일 안의 `jsx live` 블록은 텍스트 문자열이다. 브라우저는 JSX를 직접 실행하지 못한다. 이 문자열을 실행 가능한 React 엘리먼트로 만드는 방법이 핵심 기술 문제였다.

직접 구현한다면 `@babel/standalone`으로 JSX 문자열을 트랜스파일하고 `new Function`으로 실행하는 파이프라인을 만들어야 한다. 가능하지만 edge case가 많다. 에러 처리, sandbox 격리, scope 주입을 전부 직접 구현해야 한다.

`react-live`가 이 문제를 이미 해결했다. 내부적으로 sucrase를 사용해서 JSX를 트랜스파일하고, `LiveProvider`가 scope를 주입하고, `LiveError`가 에러를 표시하고, `LivePreview`가 렌더링 결과를 보여준다. 이미 해결된 문제를 다시 구현하지 않는다는 원칙에 맞는다.

`react-live`의 scope가 가져오는 부수 효과도 중요하다. `jsx live` 블록에서 쓸 수 있는 컴포넌트가 scope에 등록된 것으로 제한된다. 에이전트가 카탈로그에 없는 컴포넌트를 임의로 쓰지 못하는 구조가 기술적으로 강제된다. 설계 의도가 코드로 강제되는 것이다.

---

## 결정 3: 마크다운 파싱은 remark를 사용한다

마크다운 파일에서 `jsx live` 블록을 추출하는 방법이 두 가지였다. 정규식으로 직접 추출하거나, remark로 AST를 만들고 코드 블록 노드를 순회하는 것이다.

정규식은 단순한 경우에 작동한다. 그런데 코드 블록 안에 코드 블록이 중첩되거나, 마크다운 문법이 복잡해지면 정규식이 깨진다. 마크다운 파싱은 정규식으로 완전하게 구현하기 어려운 영역이다.

remark가 이 문제를 구조적으로 해결한다. 마크다운을 AST로 변환하면 코드 블록이 `code` 노드가 되고, 그 노드의 `lang` 속성이 `jsx`이고 `meta` 속성이 `live`인 것을 찾으면 된다. 정규식보다 안정적이고, 나중에 다른 파싱 로직을 추가할 때도 AST 위에서 작업하면 된다.

```javascript
// remark가 마크다운을 AST로 변환한다
// 코드 블록 노드를 찾아서 jsx live 블록을 식별한다
import { remark } from 'remark';
import { visit } from 'unist-util-visit';

function extractLiveBlocks(markdown) {
  const blocks = [];
  const tree = remark().parse(markdown);

  visit(tree, 'code', (node) => {
    // lang이 jsx이고 meta가 live인 블록만 Island로 만든다
    if (node.lang === 'jsx' && node.meta === 'live') {
      blocks.push(node.value);
    }
  });

  return blocks;
}
```

---

## 결정 4: CSS Isolation은 Tailwind 통일로 해결한다

CSS Isolation이 뷰어에서 현실적인 문제가 되는 이유가 있다. 뷰어 자체의 CSS와 Island 안의 컴포넌트 CSS가 같은 DOM에 존재하면 서로 간섭한다. 전역 스타일이 Island 안으로 들어오고, Island의 스타일이 뷰어 레이아웃을 망가뜨린다.

Shadow DOM, CSS Modules, iframe 세 가지를 검토했다.

Shadow DOM은 브라우저가 네이티브로 지원하는 완전한 격리다. 그런데 React의 이벤트 시스템이 Shadow DOM 경계에서 버블링이 완전하지 않은 문제가 있다. Tailwind CSS가 `<head>`에 올라가는데 Shadow DOM이 그것을 상속받지 않는 문제도 있다. 추가 작업이 필요하다.

iframe은 가장 완전한 격리를 제공한다. 독립적인 브라우저 컨텍스트여서 CSS가 완전히 분리된다. 그런데 Island 안의 컴포넌트 높이를 측정해서 iframe 높이를 동적으로 맞추는 작업이 필요하다. 구현 비용이 있다.

뷰어와 컴포넌트 라이브러리가 둘 다 Tailwind를 쓰면 격리 문제가 구조적으로 사라진다. Tailwind는 유틸리티 클래스이고 각 클래스가 하나의 CSS 속성에 대응한다. 같은 클래스가 뷰어와 Island 양쪽에 있어도 같은 스타일이기 때문에 충돌이 없다. 전역 CSS가 없고 유틸리티 클래스만 있기 때문이다.

이 결정이 유효한 전제가 있다. 컴포넌트 라이브러리가 Tailwind로 작성되어 있어야 한다. 만약 컴포넌트 라이브러리가 전역 CSS나 CSS-in-JS를 쓴다면 이 결정을 재검토해야 한다. 그 시점에 iframe을 도입하는 것이 현실적인 선택이다.

---

## 결정 5: 서버 사이드 렌더링과 Hydration을 사용하지 않는다

Hydration은 서버가 React 컴포넌트를 먼저 렌더링해서 HTML을 만들고, 브라우저가 그 HTML에 JavaScript를 붓는 방식이다. 초기 로딩 속도가 빠르고 SEO에 유리하다.

그런데 이 뷰어에 Hydration이 맞지 않는 이유가 있다. Hydration이 작동하려면 서버가 `jsx live` 블록의 코드를 빌드 타임 또는 요청 타임에 알고 있어야 한다. component-catalog.md는 정적 파일이고, `jsx live` 블록은 사용자가 파일을 수정할 때마다 바뀐다. 서버와 클라이언트가 항상 같은 코드를 가지고 있다는 보장이 없다. Hydration mismatch가 구조적으로 발생할 수 있다.

SEO가 필요 없는 내부 도구이고, 초기 로딩 속도가 중요한 서비스가 아니다. 브라우저가 md 파일을 fetch로 읽고 `react-live`로 렌더링하는 순수 클라이언트 사이드 방식으로 충분하다. 정적 파일 서버 하나면 작동한다.

---

## 결정 6: 설정 파일을 최소화한다

이 결정이 다른 결정들의 기준이 됐다. 설정이 필요한 순간 스토리북과 같은 방향으로 가는 것이다.

현재 필요한 설정 파일은 `vite.config.js` 하나다. 그 안에서 React 플러그인을 추가하고, md 파일을 정적 자산으로 서빙하는 설정을 한다. 그 외에는 없다. 네비게이션은 마크다운 헤딩 구조에서 자동으로 생성되기 때문에 별도의 네비게이션 설정 파일이 없다. 컴포넌트 등록은 `react-live`의 scope 객체에 import해서 넣는 것으로 끝난다.

이 결정의 트레이드오프가 있다. 설정이 적다는 것은 커스터마이징 가능성도 적다는 것이다. 다른 팀이 이 뷰어를 가져다 쓸 때 자신의 환경에 맞게 바꾸기 어려울 수 있다. 그런데 오늘 이 뷰어의 목적은 팀장인 나의 블로커를 제거하는 것이다. 다른 팀의 커스터마이징 필요는 그 팀이 직접 fork해서 수정하면 된다. 범용 도구를 만드는 것이 목적이 아니다.

---

## 결정 요약

```
문제                      선택          대안              선택 이유
JSX 문자열 렌더링         react-live    직접 구현         이미 해결된 문제를 재구현하지 않는다
마크다운 파싱             remark        정규식            AST가 더 안정적이다
빌드 도구                 Vite          Vanilla JS        팀 표준, TypeScript 지원
                                        Next.js           불필요한 복잡도
CSS Isolation             Tailwind 통일 Shadow DOM        React 이벤트 버블링 문제
                                        iframe            구현 비용
렌더링 방식               CSR           SSR + Hydration   정적 파일로 충분하다
```

---

## 재검토 조건

이 결정들이 유효한 전제가 깨지면 재검토한다.

CSS Isolation 결정은 컴포넌트 라이브러리가 Tailwind로 작성되어 있다는 전제 위에 있다. 전역 CSS를 쓰는 컴포넌트가 생기면 iframe 도입을 검토한다.

Vite 결정은 팀 표준이 바뀌면 재검토한다. 팀이 다른 빌드 도구로 이동하면 뷰어도 따라간다.

설정 최소화 결정은 다른 팀이 갖다 쓰면서 커스터마이징 요구가 생기면 재검토한다. 그런데 그 시점에 범용 도구로 만들 것인지, fork를 권장할 것인지를 먼저 결정한다. 범용 도구가 되는 순간 스토리북과 같은 방향으로 가는 위험이 있다.
